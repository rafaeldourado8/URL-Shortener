version: '3.8'

services:
  # --- API Backend ---
  app:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    image: url-shortener-backend:latest
    container_name: shortener_api
    # Comando otimizado para produção
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4 --proxy-headers
    restart: always
    ports:
      - "8000:8000"
    env_file:
      - ./backend/.env
    environment:
      # Garante que pegamos as variáveis do GitHub Actions/EC2
      - DATABASE_WRITE_URL=${DATABASE_WRITE_URL}
      - DATABASE_READ_URLS=${DATABASE_READ_URLS}
      - REDIS_URL=${REDIS_URL}
      - BASE_URL=${BASE_URL}
    networks:
      - backend_network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # --- Nginx (Load Balancer & Proxy) ---
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    image: url-shortener-nginx:latest
    container_name: shortener_nginx
    restart: always
    ports:
      - "80:80"
      # - "443:443" # Descomente apenas se já tiver certificado SSL configurado
    volumes:
      - ./nginx/nginx.prod.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - backend_network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # --- Redis (Cache Local) ---
  # Nota: Se você usar AWS ElastiCache, este container será ignorado pela app,
  # mas mantê-lo aqui serve como fallback se a conexão AWS falhar.
  redis:
    image: redis:7-alpine
    container_name: shortener_redis
    restart: always
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - backend_network

networks:
  backend_network:
    driver: bridge

volumes:
  redis_data:
    driver: local